From a319d228ee70d1fbd8aa3429b8f4f3963ab0348a Mon Sep 17 00:00:00 2001
From: Martin Jansa <Martin.Jansa@gmail.com>
Date: Wed, 17 Dec 2014 18:15:30 +0100
Subject: [PATCH 1/3] luna_methods: drop trailing whitespaces

Signed-off-by: Martin Jansa <Martin.Jansa@gmail.com>
---
 src/luna_methods.c | 100 +++++++++++++++++++++---------------------
 1 file changed, 50 insertions(+), 50 deletions(-)

diff --git a/src/luna_methods.c b/src/luna_methods.c
index 6deafa3..015caa1 100644
--- a/src/luna_methods.c
+++ b/src/luna_methods.c
@@ -101,14 +101,14 @@ static char *json_escape_str(char *str)
 	memcpy(resultsPt, str + start_offset, pos - start_offset);
 	resultsPt += pos - start_offset;
       };
-      
+
       // Escape the character
-      if      (c == '\b') {memcpy(resultsPt, "\\b",  2); resultsPt += 2;} 
-      else if (c == '\n') {memcpy(resultsPt, "\\n",  2); resultsPt += 2;} 
-      else if (c == '\r') {memcpy(resultsPt, "\\r",  2); resultsPt += 2;} 
-      else if (c == '\t') {memcpy(resultsPt, "\\t",  2); resultsPt += 2;} 
-      else if (c == '"')  {memcpy(resultsPt, "\\\"", 2); resultsPt += 2;} 
-      else if (c == '\\') {memcpy(resultsPt, "\\\\", 2); resultsPt += 2;} 
+      if      (c == '\b') {memcpy(resultsPt, "\\b",  2); resultsPt += 2;}
+      else if (c == '\n') {memcpy(resultsPt, "\\n",  2); resultsPt += 2;}
+      else if (c == '\r') {memcpy(resultsPt, "\\r",  2); resultsPt += 2;}
+      else if (c == '\t') {memcpy(resultsPt, "\\t",  2); resultsPt += 2;}
+      else if (c == '"')  {memcpy(resultsPt, "\\\"", 2); resultsPt += 2;}
+      else if (c == '\\') {memcpy(resultsPt, "\\\\", 2); resultsPt += 2;}
 
       // Reset the start of the next chunk
       start_offset = ++pos;
@@ -116,7 +116,7 @@ static char *json_escape_str(char *str)
     }
 
     default:
-      
+
       // Check for "special" characters
       if ((c < ' ') || (c > 127)) {
 
@@ -145,7 +145,7 @@ static char *json_escape_str(char *str)
   if (pos - start_offset > 0) {
     memcpy(resultsPt, str + start_offset, pos - start_offset);
     resultsPt += pos - start_offset;
-  } 
+  }
 
   // Terminate the output buffer ...
   memcpy(resultsPt, "\0", 1);
@@ -350,7 +350,7 @@ static bool run_command(char *command, LSMessage *message, subscribefun subscrib
 
     // Read and store characters up to the next LF or NL.
     int c;
-    while ((len < MAXLINLEN) && ((c = fgetc(fp)) != EOF)) { 
+    while ((len < MAXLINLEN) && ((c = fgetc(fp)) != EOF)) {
       // Rewind the buffer for carriage returns without a linefeed.
       if (c == '\r') {
 	*lastpos = '\0';
@@ -758,7 +758,7 @@ void *update_thread(void *arg) {
 
     // Even if there is an error, continue to move the files below
   }
- 
+
   // Create the cache directory
   strcpy(command, "/bin/mkdir -p /media/cryptofs/apps/var/lib/opkg/cache 2>&1");
   strcpy(run_command_buffer, "[");
@@ -768,7 +768,7 @@ void *update_thread(void *arg) {
     error = true;
     // Even if there is an error, continue to move the files below
   }
- 
+
   // Remove any existing cache files
   strcpy(command, "/bin/rm -f /media/cryptofs/apps/var/lib/opkg/cache/* 2>&1");
   strcpy(run_command_buffer, "[");
@@ -778,7 +778,7 @@ void *update_thread(void *arg) {
     error = true;
     // Even if there is an error, continue to move the files below
   }
- 
+
   // Determine if any feeds were updated
   bool anyfeeds = false;
   DIR *dp = opendir ("/media/cryptofs/apps/var/lib/opkg/lists/");
@@ -803,7 +803,7 @@ void *update_thread(void *arg) {
       // At this point, we're done anyway
     }
   }
- 
+
   // Report the error status of the initial update command
   if (error) {
     if (!LSMessageRespond(message, "{\"returnValue\": false, \"stage\": \"failed\"}", &lserror)) goto error;
@@ -858,11 +858,11 @@ static bool read_file(LSMessage *message, char *filename) {
     sprintf(read_file_buffer,
 	    "{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Cannot open %s\"}",
 	    filename);
-    
+
     if (!LSMessageRespond(message, read_file_buffer, &lserror)) goto error;
     return true;
   }
-  
+
   char chunk[CHUNKSIZE];
   int chunksize = CHUNKSIZE;
 
@@ -922,7 +922,7 @@ bool get_list_file_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
 
   // Extract the feed argument from the message
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  json_t *id = json_find_first_label(object, "feed");               
+  json_t *id = json_find_first_label(object, "feed");
   if (!id || (id->child->type != JSON_STRING) || (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing feed\"}",
@@ -960,7 +960,7 @@ bool get_package_info_method(LSHandle *lshandle, LSMessage *message, void *ctx)
   int datasize = 0;
 
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  json_t *id = json_find_first_label(object, "package");               
+  json_t *id = json_find_first_label(object, "package");
 
   if (!id || (id->child->type != JSON_STRING) || (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
     if (!LSMessageRespond(message,
@@ -1001,7 +1001,7 @@ bool get_package_info_method(LSHandle *lshandle, LSMessage *message, void *ctx)
   g_dir_close(dir);
 
   if (!package) {
-    if (!LSMessageRespond(message, 
+    if (!LSMessageRespond(message,
           "{\"returnValue\": true, \"size\": 0, \"contents\": \"\"}", &lserror)) {
       goto error;
     }
@@ -1053,7 +1053,7 @@ bool get_control_file_method(LSHandle* lshandle, LSMessage *message, void *ctx)
 
   // Extract the feed argument from the message
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  json_t *id = json_find_first_label(object, "package");               
+  json_t *id = json_find_first_label(object, "package");
   if (!id || (id->child->type != JSON_STRING) || (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing package\"}",
@@ -1094,7 +1094,7 @@ bool get_appinfo_file_method(LSHandle* lshandle, LSMessage *message, void *ctx)
 
   // Extract the feed argument from the message
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  json_t *id = json_find_first_label(object, "package");               
+  json_t *id = json_find_first_label(object, "package");
   if (!id || (id->child->type != JSON_STRING) || (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing package\"}",
@@ -1222,7 +1222,7 @@ bool set_config_state_method(LSHandle* lshandle, LSMessage *message, void *ctx)
   json_t *id;
 
   // Extract the config argument from the message
-  id = json_find_first_label(object, "config");               
+  id = json_find_first_label(object, "config");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXNAMLEN) ||
       (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
@@ -1284,7 +1284,7 @@ bool add_config_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   json_t *id;
 
   // Extract the config argument from the message
-  id = json_find_first_label(object, "config");               
+  id = json_find_first_label(object, "config");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXNAMLEN) ||
       (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
@@ -1298,7 +1298,7 @@ bool add_config_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   strcpy(config, id->child->text);
 
   // Extract the name argument from the message
-  id = json_find_first_label(object, "name");               
+  id = json_find_first_label(object, "name");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXNAMLEN) ||
       (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
@@ -1312,7 +1312,7 @@ bool add_config_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   strcpy(name, id->child->text);
 
   // Extract the url argument from the message
-  id = json_find_first_label(object, "url");               
+  id = json_find_first_label(object, "url");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -1366,7 +1366,7 @@ bool delete_config_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   json_t *id;
 
   // Extract the config argument from the message
-  id = json_find_first_label(object, "config");               
+  id = json_find_first_label(object, "config");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXNAMLEN) ||
       (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
@@ -1380,7 +1380,7 @@ bool delete_config_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   strcpy(config, id->child->text);
 
   // Extract the name argument from the message
-  id = json_find_first_label(object, "name");               
+  id = json_find_first_label(object, "name");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXNAMLEN) ||
       (strspn(id->child->text, ALLOWED_CHARS) != strlen(id->child->text))) {
@@ -1501,7 +1501,7 @@ void *feed_download_thread(void *arg) {
   LSMessage *message = (LSMessage *)arg;
 
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  
+
   // Extract the gzipped argument from the message
   json_t *gzipped = json_find_first_label(object, "gzipped");
   if (!gzipped || ((gzipped->child->type != JSON_TRUE) && (gzipped->child->type != JSON_FALSE))) {
@@ -1527,7 +1527,7 @@ void *feed_download_thread(void *arg) {
   }
 
   // Extract the url argument from the message
-  json_t *url = json_find_first_label(object, "url");               
+  json_t *url = json_find_first_label(object, "url");
   if (!url || (url->child->type != JSON_STRING) ||
       (strlen(url->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -1584,7 +1584,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
 
   char *installCommand;
   subscribefun installFilter;
-  
+
   bool installed = false;
 
   if (useSvc) {
@@ -1697,7 +1697,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
 
       snprintf(command, MAXLINLEN,
 	       "/bin/mkdir -p /media/cryptofs/apps/.scripts/%s 2>&1", package);
-      
+
       strcpy(run_command_buffer, "{\"stdOut\": [");
       if (run_command(command, message, passthrough)) {
 	strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"mkdir-prerm\"}");
@@ -1711,7 +1711,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
 
       snprintf(command, MAXLINLEN,
 	       "/usr/bin/install -m 755 %s /media/cryptofs/apps/.scripts/%s/pmPreRemove.script 2>&1", prerm, package);
-      
+
       strcpy(run_command_buffer, "{\"stdOut\": [");
       if (run_command(command, message, passthrough)) {
 	strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"install-prerm\"}");
@@ -1724,7 +1724,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
       }
     }
   }
- 
+
   /* Check for an opkg postinst script, and run it */
 
   char postinst[MAXLINLEN];
@@ -1741,7 +1741,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
 
       snprintf(command, MAXLINLEN,
 	       "OPKG_OFFLINE_ROOT=/media/cryptofs/apps /bin/sh %s 2>&1", postinst);
-      
+
       strcpy(run_command_buffer, "{\"stdOut\": [");
       if (run_command(command, message, passthrough)) {
 	strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"postinst\"}");
@@ -1762,7 +1762,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
   if (!installed) {
     snprintf(command, MAXLINLEN,
 	     "/usr/bin/opkg -o /media/cryptofs/apps remove %s 2>&1", package);
-    
+
     strcpy(run_command_buffer, "{\"stdOut\": [");
     if (run_command(command, message, appinstaller)) {
       strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"remove\"}");
@@ -1776,7 +1776,7 @@ bool do_install(LSMessage *message, char *filename, char *url, bool useSvc) {
 
     snprintf(command, MAXLINLEN,
 	     "/bin/rm -rf /media/cryptofs/apps/usr/palm/applications/%s /media/cryptofs/apps/.scripts/%s 2>&1", package, package);
-    
+
     strcpy(run_command_buffer, "{\"stdOut\": [");
     if (run_command(command, message, appinstaller)) {
       strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"delete\"}");
@@ -1826,7 +1826,7 @@ bool do_remove(LSMessage *message, char *package, bool replace, bool *removed) {
 
     snprintf(command, MAXLINLEN,
 	     "OPKG_OFFLINE_ROOT=/media/cryptofs/apps /bin/sh %s 2>&1", prerm);
-      
+
     strcpy(run_command_buffer, "{\"stdOut\": [");
     if (run_command(command, message, passthrough)) {
       strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"prerm\"}");
@@ -1868,10 +1868,10 @@ bool do_remove(LSMessage *message, char *package, bool replace, bool *removed) {
     // Assume that it hasn't been removed properly (don't change *removed)
     return true;
   }
-  
+
   snprintf(command, MAXLINLEN,
 	   "/bin/rm -rf /media/cryptofs/apps/usr/palm/applications/%s /media/cryptofs/apps/.scripts/%s 2>&1", package, package);
-    
+
   strcpy(run_command_buffer, "{\"stdOut\": [");
   if (run_command(command, message, appinstaller)) {
     strcat(run_command_buffer, "], \"returnValue\": true, \"stage\": \"delete\"}");
@@ -1904,7 +1904,7 @@ void *appinstaller_install_thread(void *arg) {
   LSMessage *message = (LSMessage *)arg;
 
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  
+
   // Extract the filename argument from the message
   json_t *filename = json_find_first_label(object, "filename");
   if (!filename || (filename->child->type != JSON_STRING) ||
@@ -1919,7 +1919,7 @@ void *appinstaller_install_thread(void *arg) {
   }
 
   // Extract the url argument from the message
-  json_t *url = json_find_first_label(object, "url");               
+  json_t *url = json_find_first_label(object, "url");
   if (!url || (url->child->type != JSON_STRING) ||
       (strlen(url->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -1969,7 +1969,7 @@ void *opkg_install_thread(void *arg) {
   LSMessage *message = (LSMessage *)arg;
 
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  
+
   // Extract the filename argument from the message
   json_t *filename = json_find_first_label(object, "filename");
   if (!filename || (filename->child->type != JSON_STRING) ||
@@ -1984,7 +1984,7 @@ void *opkg_install_thread(void *arg) {
   }
 
   // Extract the url argument from the message
-  json_t *url = json_find_first_label(object, "url");               
+  json_t *url = json_find_first_label(object, "url");
   if (!url || (url->child->type != JSON_STRING) ||
       (strlen(url->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -2113,7 +2113,7 @@ void *opkg_replace_thread(void *arg) {
   }
 
   // Extract the url argument from the message
-  json_t *url = json_find_first_label(object, "url");               
+  json_t *url = json_find_first_label(object, "url");
   if (!url || (url->child->type != JSON_STRING) ||
       (strlen(url->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -2194,7 +2194,7 @@ void *appinstaller_replace_thread(void *arg) {
   }
 
   // Extract the url argument from the message
-  json_t *url = json_find_first_label(object, "url");               
+  json_t *url = json_find_first_label(object, "url");
   if (!url || (url->child->type != JSON_STRING) ||
       (strlen(url->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -2266,7 +2266,7 @@ bool extract_control_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
   sprintf(filename, "/media/internal/.developer/%s", id->child->text);
 
   // Extract the url argument from the message
-  id = json_find_first_label(object, "url");               
+  id = json_find_first_label(object, "url");
   if (!id || (id->child->type != JSON_STRING) ||
       (strlen(id->child->text) >= MAXLINLEN)) {
     if (!LSMessageRespond(message,
@@ -2390,7 +2390,7 @@ bool impersonate_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
 
   // Extract the method argument from the message
   json_t *object = json_parse_document(LSMessageGetPayload(message));
-  json_t *id = json_find_first_label(object, "id");               
+  json_t *id = json_find_first_label(object, "id");
   if (!id || (id->child->type != JSON_STRING)) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing id\"}",
@@ -2400,7 +2400,7 @@ bool impersonate_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
 
   // Extract the service argument from the message
   object = json_parse_document(LSMessageGetPayload(message));
-  json_t *service = json_find_first_label(object, "service");               
+  json_t *service = json_find_first_label(object, "service");
   if (!service || (service->child->type != JSON_STRING)) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing service\"}",
@@ -2410,7 +2410,7 @@ bool impersonate_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
 
   // Extract the method argument from the message
   object = json_parse_document(LSMessageGetPayload(message));
-  json_t *method = json_find_first_label(object, "method");               
+  json_t *method = json_find_first_label(object, "method");
   if (!method || (method->child->type != JSON_STRING)) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing method\"}",
@@ -2420,7 +2420,7 @@ bool impersonate_method(LSHandle* lshandle, LSMessage *message, void *ctx) {
 
   // Extract the params argument from the message
   object = json_parse_document(LSMessageGetPayload(message));
-  json_t *params = json_find_first_label(object, "params");               
+  json_t *params = json_find_first_label(object, "params");
   if (!params || (params->child->type != JSON_OBJECT)) {
     if (!LSMessageRespond(message,
 			"{\"returnValue\": false, \"errorCode\": -1, \"errorText\": \"Invalid or missing params\"}",
-- 
2.2.0

